#!/usr/bin/env bash

# Definitions are scattered, so that they are defined only if needed.
# Some identifiers are available to the user:
#  * uw_fatal - function to print an error message and exit.
#  * uw_setup - function to handle command completion and options.
#  * uw_root  - the workspace root, a directory that contains .uw.

# Program version, always updated in a separate tagged commit.
declare -r _uw_version="0.6.0"

###############################################################################
# CLI definitions
###############################################################################

# Commands that can only be run in a workspace.
declare -ra _uw_cli_scripts=(
    "uwa"
    "uwd"
    "uwp"
    "uwc"
    "uws"
    "uwf"
    "uwb"
    "uwi"
    "uwt"
    "uwx"
)
# Commands that can be run everywhere.
declare -ra _uw_cli_globals=(
    "app-update"
    "app-setup"
    "app-reset"
    "init"
)
# Options - each has a separate _uw_opt_* variable.
declare -ra _uw_cli_options=(
    "--bashrc"
    "--version"
    "--help"
)
# Short descriptions for the commands.
declare -rA _uw_cli_helps=(
    [uwa]="Attach to the hardware."
    [uwd]="Detach from the hardware."
    [uwp]="Manage the power state of the hardware."
    [uwc]="Copy file between the local machine and the hardware."
    [uws]="The hardware shell."
    [uwf]="Fetch the software."
    [uwb]="Build the software."
    [uwi]="Install the software."
    [uwt]="Test the software."
    [uwx]="Extensions - custom actions."
    [app-update]="Download the latest version."
    [app-setup]="Modify .bashrc to register uw completion and aliases."
    [app-reset]="Revert changes to .bashrc made by app-setup."
    [init]="Create an empty workspace."
    [--bashrc]="Setup completion and aliases, then exit."
    [--help]="Print the help text, then exit."
    [--version]="Print the version, then exit."
)

# Declare aliases for the scripts. They can be called outside a workspace.
shopt -s expand_aliases
for i in "${_uw_cli_scripts[@]}"; do
    alias "$i"="uw $i"
done

# A command to execute.
declare _uw_cli_command=""
# Option: show help.
declare _uw_cli_option_help=""
# Option: setup completion and aliases.
declare _uw_cli_option_bashrc=""
# Option: show version.
declare _uw_cli_option_version=""
# Option: perform completion instead of execution (hidden).
declare _uw_cli_option_complete=""

for i in "$@"; do
    if [[ "$i" == "--help" ]]; then
        _uw_cli_option_help="$i"
        shift
        continue
    fi
    if [[ "$i" == "--bashrc" ]]; then
        _uw_cli_option_bashrc="$i"
        shift
        continue
    fi
    if [[ "$i" == "--version" ]]; then
        _uw_cli_option_version="$i"
        shift
        continue
    fi
    if [[ "$i" == "--complete" ]]; then
        _uw_cli_option_complete="$i"
        shift
        continue
    fi
    _uw_cli_command="$i"
    shift
    break
done

###############################################################################
# Option handling
###############################################################################

# This section handles options that do not require a command:
#  * --bashrc
#  * --version
#  * --help

#
# uw --bashrc
#

# Determine the workspace root.
function _uw_root()
{
    # Search recursively backwards, starting from the current directory.
    declare uw_root="$PWD"
    while true; do
        # Found.
        if [[ -d "$uw_root/.uw" ]]; then
            break
        fi
        # Not found up to the root directory.
        if [[ "$uw_root" == "/" ]]; then
            uw_root=""
            break
        fi
        # Not found, recurse into the parent directory.
        uw_root="$(dirname "$uw_root")"
    done
    echo "$uw_root"
}

function _uw_completion()
{
    # Redeclare _uw_cli_command as local, parse it from COMP_WORDS.
    declare _uw_cli_command=""
    if [[ "${COMP_WORDS[0]}" != "uw" ]]; then
        # Case of a uw* alias.
        _uw_cli_command="${COMP_WORDS[0]}"
    else
        # Case of the uw application.
        for i in "${!COMP_WORDS[@]}"; do
            # Filter out uw itself and its options.
            if false \
                || (( $i == 0 )) \
                || [[ "${COMP_WORDS[$i]}" == "--help" ]] \
                || [[ "${COMP_WORDS[$i]}" == "--bashrc" ]] \
                || [[ "${COMP_WORDS[$i]}" == "--version" ]] \
                || [[ "${COMP_WORDS[$i]}" == "--complete" ]] \
                ; then
                continue
            fi
            # The first non-special word is the command (command completion).
            # Skip if it is the word to complete (application completion).
            if (( $i != $COMP_CWORD )); then
                _uw_cli_command="${COMP_WORDS[$i]}"
            fi
            break
        done
    fi
    # All completion suggestions as a single string.
    declare compwords=""
    if [[ -n "$_uw_cli_command" ]]; then
        # The command completion.
        # Set COMPREPLY words for options or targets (arguments).
        if [[ "${COMP_WORDS[$COMP_CWORD]:0:1}" == "-" ]]; then
            compwords="--help --version"
        else
            compwords="$(uw --complete "$_uw_cli_command" 2>/dev/null || true)"
        fi
    else
        # The application completion.
        # Dynamically determine the workspace root.
        declare -r uw_root="$(_uw_root)"
        # Populate the available commands.
        declare -a _uw_cli_commands=()
        if [[ -n "$uw_root" ]]; then
            _uw_cli_commands+=("${_uw_cli_scripts[@]}")
        fi
        _uw_cli_commands+=("${_uw_cli_globals[@]}")
        # Set COMPREPLY words for options or commands.
        if [[ "${COMP_WORDS[$COMP_CWORD]:0:1}" == "-" ]]; then
            compwords="${_uw_cli_options[*]}"
        else
            compwords="${_uw_cli_commands[*]}"
        fi
    fi
    # Generate actual completions.
    COMPREPLY=($(compgen -W "$compwords" -- "${COMP_WORDS[$COMP_CWORD]}"))
}

# It should be handled first, so that the script returns before polluting the
# namespace with more identifiers.
if [[ -n "$_uw_cli_option_bashrc" ]]; then
    complete -o filenames -o bashdefault -o default -F _uw_completion uw
    for i in "${_uw_cli_scripts[@]}"; do
        complete -o filenames -o bashdefault -o default -F _uw_completion "$i"
    done
    # Cleanup, since whatever is defined stays permanently.
    unset _uw_version
    unset _uw_cli_command
    unset _uw_cli_option_help
    unset _uw_cli_option_bashrc
    unset _uw_cli_option_version
    unset _uw_cli_option_complete
    unset _uw_arg
    return
fi

#
# uw --version
#

if [[ -n "$_uw_cli_option_version" ]]; then
    echo "$_uw_version"
    exit 0
fi

#
# uw --help
#

# Print an argument section.
#
# Parameters:
#  * title - the section title, the first argument ($1).
#  * names - a reference to a list of arguments ($2).
#  * helps - a reference to a list of helps for the arguments ($3).
function _uw_print_args()
{
    # Parse arguments.
    declare -r title="$1"
    declare -n names="$2"
    declare -n helps="$3"
    # Determine the longest argument name.
    declare length=0
    for i in "${names[@]}"; do
        if (( ${#i} > $length )); then
            length=${#i}
        fi
    done
    # Print the section.
    printf "\n$title:\n"
    for i in "${names[@]}"; do
        printf "  %-${length}s    ${helps[$i]}\n" "$i"
    done
}

if [[ -n "$_uw_cli_option_help" ]]; then
    # Print the header.
    printf "%s\n" \
        "uw ..." \
        "" \
        "Uniform Workspace version $_uw_version."
    # Populate the available commands.
    declare -a _uw_cli_commands=()
    if [[ -n "$(_uw_root)" ]]; then
        _uw_cli_commands+=("${_uw_cli_scripts[@]}")
    fi
    _uw_cli_commands+=("${_uw_cli_globals[@]}")
    # Print the commands.
    _uw_print_args "Commands" "_uw_cli_commands" "_uw_cli_helps"
    # Print optional arguments.
    _uw_print_args "Optional arguments" "_uw_cli_options" "_uw_cli_helps"
    echo
    exit 0
fi

###############################################################################
# Command handling
###############################################################################

# Print an error message and exit. Also available to the user.
#
# Parameters:
#  * 1 - the message.
#  * 2 - the exit code, defaults to 1.
function uw_fatal()
{
    echo "$1" >&2
    declare -r code=${2:-1}
    exit $code
}

# Handle the following options per command:
#  * --help
#  * --version
#  * --complete (the global one)
# This function should be called at the start of each command execution.
# Generated uw*.sh scripts already include the call. The user is supposed to
# extend it by providing a list of suggested values for the TGT argument.
#
# Parameters:
#  * uw_argc - a number of arguments passed to the command.
#  * uw_argv - the next uw_argc values, arguments passed to the command.
#  * uw_tgts - suggested values for the TGT argument, if applicable.
function uw_setup()
{
    set -e
    # The number of arguments.
    declare -r uw_argc=$1
    # The arguments.
    declare -r uw_argv=("${@:2:$uw_argc}")
    # The targets - a list of possible values for the TGT argument.
    declare -r uw_tgts=("${@:$(($uw_argc + 2))}")
    # uw --complete <cmd>
    if [[ -n "$_uw_cli_option_complete" ]]; then
        printf "%s\n" "${uw_tgts[@]}"
        exit 0
    fi
    # uw <cmd> --version
    if [[ "${uw_argv[0]}" == "--version" ]]; then
        echo "$_uw_version"
        exit 0
    fi
    # uw <cmd> --help
    if [[ "${uw_argv[0]}" == "--help" ]]; then
        # Any command must not have positional argument names that exceed three
        # letters. This is to have a consistent offset for printing uw_tgts and
        # not calcualte it dynamically.
        # Each command must define the following:
        declare uw_usage=""      # A usage string for the help text.
        declare -a uw_argsp=()   # Positional arguments.
        declare -a uw_argso=(    # Optional arguments.
            "--help"
            "--version"
        )
        declare -A uw_helps=(    # Help texts for the positional arguments.
            [--help]="${_uw_cli_helps[--help]}"
            [--version]="${_uw_cli_helps[--version]}"
        )
        # app-*
        if false \
            || [[ "$_uw_cli_command" == "app-update" ]] \
            || [[ "$_uw_cli_command" == "app-reset" ]] \
            || [[ "$_uw_cli_command" == "app-setup" ]] \
            ; then
            uw_usage="uw $_uw_cli_command"
        fi
        # init
        if [[ "$_uw_cli_command" == "init" ]]; then
            uw_usage="uw $_uw_cli_command [DIR]"
            uw_argsp+=("DIR")
            uw_helps+=([DIR]="A directory to initialize, defaults to PWD.")
        fi
        # uwa
        if [[ "$_uw_cli_command" == "uwa" ]]; then
            uw_usage="uw $_uw_cli_command [TGT]"
            uw_argsp+=("TGT")
            uw_helps+=([TGT]="A target to attach to.")
        fi
        # uwd
        if [[ "$_uw_cli_command" == "uwd" ]]; then
            uw_usage="uw $_uw_cli_command"
        fi
        # uwp
        if [[ "$_uw_cli_command" == "uwp" ]]; then
            uw_usage="uw $_uw_cli_command [TGT]"
            uw_argsp+=("TGT")
            uw_helps+=([TGT]="A power state to set.")
        fi
        # uwc
        if [[ "$_uw_cli_command" == "uwc" ]]; then
            uw_usage="uw $_uw_cli_command [TGT:]SRC [TGT:]DST"
            uw_argsp+=("SRC")
            uw_argsp+=("DST")
            uw_argsp+=("TGT")
            uw_helps+=([SRC]="Source path.")
            uw_helps+=([DST]="Destination path.")
            uw_helps+=([TGT]="A target for file transfer.")
        fi
        # uws
        if [[ "$_uw_cli_command" == "uws" ]]; then
            uw_usage="uw $_uw_cli_command [TGT] [CMD...]"
            uw_argsp+=("CMD")
            uw_argsp+=("TGT")
            uw_helps+=([CMD]="A command to execute. If empty - start an interactive session.")
            uw_helps+=([TGT]="A target for shell.")
        fi
        # uwf, uwb, uwi, uwt, uwx.
        if false \
            || [[ "$_uw_cli_command" == "uwf" ]] \
            || [[ "$_uw_cli_command" == "uwb" ]] \
            || [[ "$_uw_cli_command" == "uwi" ]] \
            || [[ "$_uw_cli_command" == "uwt" ]] \
            || [[ "$_uw_cli_command" == "uwx" ]] \
            ; then
            uw_usage="uw $_uw_cli_command [TGT...]"
            uw_argsp+=("TGT")
            uw_helps+=([TGT]="Targets for the operation.")
        fi
        # Print usage.
        printf "$uw_usage\n"
        # Print description.
        printf "\n${_uw_cli_helps[$_uw_cli_command]}\n"
        # Print positional arguments.
        if [[ -n "${uw_argsp[*]}" ]]; then
            _uw_print_args "Positional arguments" "uw_argsp" "uw_helps"
            # Print the suggested values for TGT with a proper offset.
            for uw_tgt in "${uw_tgts[@]}"; do
                printf "          * $uw_tgt\n"
            done
        fi
        # Print optional arguments.
        _uw_print_args "Optional arguments" "uw_argso" "uw_helps"
        exit 0
    fi
    # Normal execution - continue.
    return
}

#
# uw
#

if [[ -z "$_uw_cli_command" ]]; then
    uw_fatal "uw: The command must be specified."
fi

#
# uw app-update
#

# The function is required to make sure that the commands are read and executed at once.
# The script lines are likely to be shifted after the update. Since bash typically reads
# and executes scripts part-by-part, a simple implementation might cause weird errors.
function _uw_update
{
    curl -o "$(which uw)" https://raw.githubusercontent.com/deohayer/uw/main/uw
    exit 0
}

if [[ "$_uw_cli_command" == "app-update" ]]; then
    uw_setup $# "$@"
    _uw_update
fi

#
# uw app-setup
#

if [[ "$_uw_cli_command" == "app-setup" ]]; then
    uw_setup $# "$@"
    printf '\nsource "$(which uw)" --bashrc 2>/dev/null || true\n' >> "${HOME}/.bashrc"
    exit 0
fi

#
# uw app-reset
#

if [[ "$_uw_cli_command" == "app-reset" ]]; then
    uw_setup $# "$@"
    sed -i '/source "$(which uw)" --bashrc 2>\/dev\/null || true/d' "${HOME}/.bashrc"
    exit 0
fi

#
# uw init
#

if [[ "$_uw_cli_command" == "init" ]]; then
    uw_setup $# "$@"
    # Default to the current directory.
    declare -r _uw_dir="$(realpath "${1:-"$PWD"}")"
    mkdir -p "$_uw_dir"
    # The directory is already a workspace.
    if [[ -e "$_uw_dir/.uw" ]]; then
        uw_fatal "uw init: Already initialized: $_uw_dir"
    fi
    # Populate .uw.
    mkdir -p "$_uw_dir/.uw"
    # Populate env.sh
    printf '# This script is sourced before execution of any uw* script.\n' > "$_uw_dir/.uw/env.sh"
    # Populate uw*.sh
    for i in "${_uw_cli_scripts[@]}"; do
        printf "%s\n" \
            '#!/usr/bin/env bash' \
            'uw_setup $# "$@"' \
            'uw_fatal "Not implemented."' \
            > "$_uw_dir/.uw/$i.sh"
    done
    # Success.
    exit 0
fi

#
# uw uw*
#

for i in "${_uw_cli_scripts[@]}"; do
    if [[ "$_uw_cli_command" == "$i" ]]; then
        # This is the value of uw_root that is available to the user.
        declare -r uw_root="$(_uw_root)"
        # Fail to execute if not in a workspace.
        if [[ -z "$uw_root" ]]; then
            uw_fatal "uw $_uw_cli_command: Only available in a workspace."
        fi
        # Execute the script.
        set -e
        source "$uw_root/.uw/env.sh"
        source "$uw_root/.uw/$_uw_cli_command.sh"
        exit 0
    fi
done

#
# uw <cmd>
#

if [[ "${_uw_cli_command:0:1}" == "-" ]]; then
    uw_fatal "uw: Unrecognized option: $_uw_cli_command"
else
    uw_fatal "uw: Unrecognized command: $_uw_cli_command"
fi
