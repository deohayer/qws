#!/usr/bin/env bash

###############################################################################
# Definition
###############################################################################

# The version has to be updated in a separate commit and tagget.
UW_VERSION="0.4.0"

# Root directory of the workspace. It is determined by recursively searcing
# an immediate .uw in the current directory and all its parents. The first
# directory to cantain .uw is the root. If empty, means the command is run
# ourside a workspace.
UW_WS="${PWD}"
while true; do
    # Found.
    if [[ -d "${UW_WS}/.uw" ]]; then
        break
    fi
    # Not found at all, reached the root directory.
    if [[ "${UW_WS}" == "/" ]]; then
        UW_WS=""
        break
    fi
    # Not found, check the parent directory.
    UW_WS="$(dirname "${UW_WS}")"
done

# All commands available to the user and respective short help messages.
# Split into two to retain the order.
declare -a UW_CMDS=()
declare -A UW_HELPS=()
# Local commands, only available in the workspace.
declare -a UW_CMDS_LOCAL=()
function _uw_cmd_local()
{
    UW_CMDS_LOCAL+=("$1")
    UW_HELPS[$1]="$2"
}
_uw_cmd_local "uwa" "Attach to hardware."
_uw_cmd_local "uwd" "Detach from hardware."
_uw_cmd_local "uwp" "Manage the power state of hardware."
_uw_cmd_local "uwc" "Copy file between the local machine and hardware."
_uw_cmd_local "uws" "Hardware shell."
_uw_cmd_local "uwf" "Fetch software."
_uw_cmd_local "uwb" "Build software."
_uw_cmd_local "uwi" "Install software."
_uw_cmd_local "uwt" "Test software."
_uw_cmd_local "uwx" "Extension commands."
# Global commands, always available.
declare -a UW_CMDS_GLOBAL=()
function _uw_cmd_global()
{
    UW_CMDS_GLOBAL+=("$1")
    UW_HELPS[$1]="$2"
}
_uw_cmd_global "app-setup" "Modify .bashrc to register uw completion and aliases."
_uw_cmd_global "app-reset" "Revert changes to .bashrc."
_uw_cmd_global "app-update" "Download the latest version of uw."
_uw_cmd_global "init" "Create an empty workspace."
# Populate actually available commands.
if [[ -n "${UW_WS}" ]]; then
    UW_CMDS+=("${UW_CMDS_LOCAL[@]}")
fi
UW_CMDS+=("${UW_CMDS_GLOBAL[@]}")

# Declare aliases for uw* commands. Ensure that they work even without .bashrc.
shopt -s expand_aliases
for i in "${UW_CMDS_LOCAL[@]}"; do
    alias "$i"="uw $i"
done

# Consume the completion flag. It is supplied by the completion function _uw().
# It instructs commands to print suggestions and abort execution.
if [[ "$1" == "--complete" ]]; then
    UW_COMPLETE="$1"
    shift
fi
# Pick the command indiscriminately. It is either a subcommand or a special
# optional argument that aborts execution.
UW_CMD="$1"
shift

# Full help text.
function _uw_help()
{
    # Print header.
    printf "\
uw ...

Uniform Workspace version ${UW_VERSION}.

Commands:
"
    # Determine the longest command name for nice formatting.
    width=0
    for i in "${UW_CMDS[@]}"; do
        if [[ $(( ${#i} > ${width} )) != "0" ]]; then
            width=${#i}
        fi
    done
    # Print commands.
    for i in "${UW_CMDS[@]}"; do
        printf " * %-${width}s - ${UW_HELPS[$i]}\n" "$i"
    done
    # Print arguments.
    printf '
Optional arguments:
  -h/--help       Display the help text and exit.
  -v/--version    Display the version and exit.
\n'
}

# Multiline string with indent removed.
function _uw_str()
{
    local s="${1:1}"
    local n=$(( $(sed -n '1s/[^[:space:]].*//; p; q' <(echo -n "$s") | wc -c) - 1 ))
    if [[ $n != 0 ]]; then
        sed 's/^[[:space:]]\{1,'"$n"'\}//' <(echo -n "$s")
    else
        echo -n "$s"
    fi
}

###############################################################################
# Completion
###############################################################################

function _uw()
{
    # First argument - case of the direct uw call.
    if [[ "${COMP_WORDS[0]}" == "uw" && "${COMP_CWORD}" == "1" ]]; then
        # Options must not be listed unless intended to be used.
        if [[ "${COMP_WORDS[${COMP_CWORD}]:0:1}" == "-" ]]; then
            # Options.
            COMPREPLY=("-h" "--help" "-v" "--version")
            COMPREPLY=($(compgen -W "-h --help -v --version" -- "${COMP_WORDS[${COMP_CWORD}]}"))
            return
        else
            # Commands.
            COMPREPLY=($(compgen -W "${UW_CMDS[*]}" -- "${COMP_WORDS[${COMP_CWORD}]}"))
            return
        fi
    fi
    # Any other argument - case of a command.
    if [[ "${COMP_WORDS[0]}" == "uw" ]]; then
        UW_CMD="${COMP_WORDS[1]}"
    else
        UW_CMD="${COMP_WORDS[0]}"
    fi
    # app-* - fallback.
    if [[ "${UW_CMD}" =~ "app-" ]]; then
        return
    fi
    # init - fallback.
    if [[ "${UW_CMD}" == "init" ]]; then
        return
    fi
    # uw* - print targets.
    if [[ "${UW_CMD}" =~ "uw" ]]; then
        COMPREPLY=($(compgen -W "$(uw --complete "${UW_CMD}" 2>/dev/null || true)" -- "${COMP_WORDS[${COMP_CWORD}]}"))
        return
    fi
}

###############################################################################
# Execution
###############################################################################

# Each section handles a single command or a group of similar commands. This
# part of the script is effectively a huge switch statement. Therefore, each
# section must call "exit" upon finishing or a command error will be printed.

#
# Missing command.
#

if [[ -z "${UW_CMD}" ]]; then
    _uw_help
    echo "uw: Command not specified."
    exit 1
fi

#
# uw --bashrc
#

# "--bashrc" is a hidden option to indicate that the file is being sourced
# from .bashrc. It should be handled first, so that the script returns before
# executing anything that can fail.
if [[ "${UW_CMD}" == "--bashrc" ]]; then
    complete -o filenames -o bashdefault -o default -F _uw "uw"
    for i in "${UW_CMDS_LOCAL[@]}"; do
        complete -o filenames -o bashdefault -o default -F _uw "$i"
    done
    return
fi

#
# uw --version
#

if [[ "${UW_CMD}" == "--version" || "${UW_CMD}" == "-v" ]]; then
    echo "${UW_VERSION}"
    exit 0
fi

#
# uw --help
#

if [[ "${UW_CMD}" == "--help" || "${UW_CMD}" == "-h" ]]; then
    _uw_help
    exit 0
fi

#
# uw app-setup
#

if [[ "${UW_CMD}" == "app-setup" ]]; then
    printf '\nsource "$(which '"uw"')" --bashrc 2>/dev/null || true\n' >> "${HOME}/.bashrc"
    exit 0
fi

#
# uw app-reset
#

if [[ "${UW_CMD}" == "app-reset" ]]; then
    # Extra newlines will not be removed by this.
    sed -i '/source "$(which '"uw"')" --bashrc 2>\/dev\/null || true/d' "${HOME}/.bashrc"
    exit 0
fi

#
# uw app-update
#

# The function is required to make sure that the commands are read and executed at once.
# The script lines are likely to be shifted after the update. Since bash typically reads
# and executes scripts part-by-part, a simple implementation might cause weird errors.
function _uw_update
{
    set -e
    curl -o "$(which "uw")" https://raw.githubusercontent.com/deohayer/uw/main/uw
    exit 0
}

if [[ "${UW_CMD}" == "app-update" ]]; then
    _uw_update
fi

#
# uw init
#

if [[ "${UW_CMD}" == "init" ]]; then
    # Overwrite UW_WS If not provided, defaults to the current directory.
    UW_WS="$(realpath "${1:-"${PWD}"}")"
    mkdir -p "${UW_WS}"
    # The directory is not empty.
    if [[ -n "$(ls -A ${UW_WS})" ]]; then
        echo "uw init: Not an empty directory: ${UW_WS}" >&2
        exit 1
    fi
    # Populate .git* and README.md.
    touch "${UW_WS}/.gitattributes"
    touch "${UW_WS}/.gitignore"
    touch "${UW_WS}/.gitmodules"
    touch "${UW_WS}/README.md"
    echo "$(_uw_str '
        *
        !.gitattributes
        !.gitignore
        !.gitmodules
        !.uw
        !.uw/**
        !.vscode
        !.vscode/**
        !README.md
        ')" > "${UW_WS}/.gitignore"
    # Populate .vscode
    mkdir -p "${UW_WS}/.vscode"
    echo "$(_uw_str '
        *
        !.gitignore
        !*.json
        ')" > "${UW_WS}/.vscode/.gitignore"
    echo "$(_uw_str '
        {
            "editor.bracketPairColorization.enabled": false,
            "files.watcherExclude": {
                "**": true
            }
        }
        ')" > "${UW_WS}/.vscode/settings.json"
    # Populate .uw.
    mkdir -p "${UW_WS}/.uw"
    echo "$(_uw_str '
        *
        !.gitignore
        !*.sh
        ')" > "${UW_WS}/.uw/.gitignore"
    # Populate env.sh
    echo "$(_uw_str '
        # This script is sourced before execution of any uw* script.
        ')" > "${UW_WS}/.uw/env.sh"
    # Populate uw*.sh
    for i in "${UW_CMDS_LOCAL[@]}"; do
        echo "$(_uw_str '
            #!/usr/bin/env bash
            uw_init "$#" "$@"
            ###############################################################################

            echo "Not implemented." >&2
            exit 1
            ')" > "${UW_WS}/.uw/$i.sh"
    done
    # Success.
    exit 0
fi

#
# uw uw*
#

function uw_init()
{
    # Arguments - whatever was passed to the script.
    local args=("${@:2:$1}")
    # Targets - a list of possible values for the script arguments.
    local tgts=("${@:$(($1 + 2))}")
    # If it is a completion request - print all targets and exit.
    if [[ -n "${UW_COMPLETE}" ]]; then
        printf "%s\n" "${tgts[@]}"
        exit 0
    fi
    # Not a completion request - continue execution.
    return
}

for i in "${UW_CMDS_LOCAL[@]}"; do
    if [[ "$i" != "${UW_CMD}" ]]; then
        continue
    fi
    if [[ -z "${UW_WS}" ]]; then
        echo "uw ${UW_CMD}: Must be run inside a workspace." >&2
        exit 1
    fi
    source "${UW_WS}/.uw/env.sh"
    source "${UW_WS}/.uw/${UW_CMD}.sh" "$@"
    exit 0
done

#
# Unknown command.
#

_uw_help
echo "uw: Unknown command: ${UW_CMD}" >&2
exit 1
